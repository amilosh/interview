 - Что такое ООП? Принципы?
Обектно-ориентированное программирование - подод к написанию программ. основанный на классах и объекта, взаимодействующи между собой.
Класс содержит свойства/поля класса (fields) и методы.
Объект - это конкретный экземпляр класса. Имеет состояние - значение все его свойств.
У класа могут быть методы с одинаковым именем, но с разными параметрами - перегруженные методы (overloaded).

  Наследование.
Это когда один класс наследуется от другого. Класс наследник наследует все свойства и методы класса родителя. В наследнике можно объявлять дополниелльные поля и 
Вызвать конструктор суперкласса - super(int age, String name)
class Cat extends Animal
Наследоваться можно только от одного класса.

Переопределение методов, Override
Класс суперкласса можно переопределить в наследнике. Можно использовать @Override. Чтоб вызвать метод суперкласса - super.show()

  Инкапсуляция.
Когда к полям класса нету доступа извне. А управлять этим полями может только сам класс - с помощью методов (всунуть валидацию).
В широком смысле - когда данные, и методы, которые управляют тими данными упакованы в один обект.

Модификаторы доступа: private, protected, package, public.

  Полиморфизм, polymorphism
Это когда в суперклассе есть метод, а у наследников - он переопределен. То есть метод имеет много форм.
Animal cat = new Cat();
Animal dog = new Dog();
cat.voice();
dog.voice();
то есть вызывается один и тот же метод, но результат будет разным
Статический полиморфизм - overloading. Динамический полиморфизм  overriding.




 - Что такое immutable? -
Почему String  - immutable.
Как создать свой immutable объект?

Слово final гарантирует неизменяемость лишь ссылки, но не самого объекта. В final ArrayList<T> можно добавлять элементы и изменять существующие.
Immutable - после окончания конструктора нельзя изменить состояние. То есть все поля - примитивы с final либо immutable типы.
Immutable - изменение в экземпляре класса приведёт к созданию новго экземпляра.
Для полей неизменяемого объекта вы практически обязаны использовать final!

Immutable:
 должен быть final, чтобы от него нельзя было наследоваться
 все поля - private
 инициализация экземпляра - в конструкторе
 не должно быть сеттеров
 для полей-коллекций необходимо делать глубокие копии, чтобы гарантировать их неизменность.

String - immutable класс.
String s = "hello";
s.toUpperCase(); - не изменит s, а вернут новую строку
String
  строки потокобезпасны
  пул строк - две разные перемнные с одиновым значенем будут указывать на одну область памяти
  хорошо использовать для ключа в коллекциях, поскольку они не могут быть изменены по ошибке
  Класс String кэширует хэш-код, что улучшает производительность хеш-коллекций, использующих String
  такие как имена пользователей и пароли, нельзя изменить по ошибке во время выполнения, даже при передаче ссылок на них между разными методами.

Если в immutable классе есть коллекция, то в конструкторе нам нужно создавать глубокую копию коллекции и сетать а свойство. И для метода get  -возвращать глубокую копию.
Потому что если мы сделаем map.put("", ""); - то это сразу прорастет в imutable оббъекте, потому что по ссыллке.

Immutable объектам не нужна синронизация в потоках.




 - Exceptions -
Почему создатели Java разделили исключения на проверяемые и не проверяемые?

Ошибки могут возникать по разным причинам. Программа должна четко знать, как поступать в такой ситуации.

Throwable - суперкласс для все ошибок.
Error extends Throwable - критические ошибки не по вине пользователя, обработать невозможно.
Exception extends Throwable

Проверяемые ошибки - их учитывает компилятор: все Exception (кроме RuntimeException) - IOException, SQLException
Непроверяемые - Error (VirtualMachineError, сбой работы JVM, переполнение памяти, сбой системы), RuntimeException (NullPointerException, IllegalArgumentException etc., ошибки программирования, компилятор не видит)

Если catch не найден - программа выводит stack trace (выполнив перед тим finally)

Try with resources - не нужен finally + несколько искллючений
try(BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))){
        s = reader.readLine();
   } catch (IOException | MyException e) {
       System.out.println(e.getMessage());
   }

Почему создатели Java разделили исключения на проверяемые и не проверяемые?
Возникновение непроверяемой ошибки зависит от самого разработчика программы. То есть он сам ответсвеннен за создание null-объектов.
А проверяемые ошибки не зависят от программиста. То есть мы обращаемся к файлу, то программист не ответственнен за то, ести ли такой файл. Поэтому такие ошибки сделали проверять.

Хорошо ннаписанный API не ддолжен заставлять свои клиентов использовать исключения.
Создание объекта исключения - ресурсоёмкая задача (собирается stack trace), нужен процессор и оперативная память.
JIT оптимизация лучше работает без исключений.
Чем меньше исключений, тем эффективнее наш код.




 - Threads -
Почему работа с потоками сложнее, чем в однопоточной среде?
Способы синхронизации ресурсов?
Как создать синхронизированную коллекцию?
Отличие потока от процесса.

Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.
Процесс не может существовать без потоков, поэтому если существует процесс, в нём существует хотя бы один поток.

1-й спсоб:
public static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello, World!");
        }
    }
public static void main(String []args){
        Thread thread = new MyThread();
        thread.start();
    }

2-й способ:
public static void main(String []args){
        Runnable task = new Runnable() {
            public void run() {
                System.out.println("Hello, World!");
            }
        };
        Thread thread = new Thread(task);
        thread.start();
    }

implements Runnable
ExecutorService executor = new Executors.ThreadPoolExecutor(2);
executor.submit(new Callable {...});
Потому что разные потоки могут работать с одними и теми же ресурсами. И эти ресурсы нужно синхронизировать.
а) synchronized void method() {} // синхронизация по методу
b) synchronized(resource) {}  // синхронизация блока
с) использование конструкции wait(), notify(), notifyAll()
d) использование ReentrantLock
Collections.getSynchronizedList(List list);
или CopyAndWriteArrayList



 - Перечислите методы класса Object -
toString(), hashCode(), equals(), clonable(), finalize(), wait(), notify(), notifyAll()

 - Какое значение возвращает метод hashCode()? -
В классе Object метод hashCode() реализован нативным образом, основывается на адресе объекта в памяти.

 - Правила equals() и hashCode()
Если equals() двух объектов равны - то и hashCode() равны.
Если hashCode() двух объектов равны - то нужно ещё проверить на equals(). (потому что hashCode - это int). Такой случай называется коллизией.
hashCode() нужен для более бстрого сравнения объектов, чем по equals()

 - Как десятичное число перевести в ддвоичное? -
Использовать метод последовательного деления на 2:
10÷2=5 остаток 0
5÷2=2 остаток 1
2÷2=1 остаток 0
1÷2=0 остаток 1
Записываем остатки в обратном порядке: 1010.
String binaryString = Integer.toBinaryString(decimalNumber);

 - Что означает 10 (десятичный) >> 2? -
Побитовый сдвиг вправо.
int number = 10;
int result = number >> 2;
10 в двоичной форме: 00001010
После сдвига вправо на 2 позиции: 00000010 (десятичное 2)